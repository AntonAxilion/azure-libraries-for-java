/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * <p>
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.resources.implementation;


import com.azure.core.annotation.*;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.rest.*;
import com.azure.core.management.PagedList;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.polling.LongRunningOperationStatus;
import com.microsoft.azure.management.resources.ExportTemplateRequest;
import com.microsoft.azure.management.resources.ResourceGroupPatchable;
import reactor.core.Exceptions;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined
 * in ResourceGroups.
 */
public class ResourceGroupsInner {
    /**
     * The Retrofit service to perform REST calls.
     */
    private ResourceGroupsService service;
    /**
     * The service client containing this operation class.
     */
    private ResourceManagementClientImpl client;


    private final ClientLogger logger = new ClientLogger(ResourceGroupsInner.class);

    /**
     * Initializes an instance of ResourceGroupsInner.
     *
     * @param client the instance of the service client containing this operation class.
     */
    public ResourceGroupsInner(HttpPipeline pipeline, ResourceManagementClientImpl client) {
        this.service = RestProxy.create(ResourceGroupsService.class, pipeline);
        this.client = client;
    }

    public ResourceGroupInner get(String resourceGroupName) {
        return this.getAsync(resourceGroupName).block();
    }

    /**
     * Gets a resource group.
     *
     * @param resourceGroupName The name of the resource group to get. The name is case insensitive.
     * @return the observable to the ResourceGroupInner object
     * @throws IllegalArgumentException thrown if parameters fail the validation
     */
    public Mono<ResourceGroupInner> getAsync(String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(resourceGroupName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
                .flatMap(res -> Mono.just(res.getValue()));
//                .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceGroupInner>>>() {
//                    @Override
//                    public Observable<ServiceResponse<ResourceGroupInner>> call(Response<ResponseBody> response) {
//                        try {
//                            ServiceResponse<ResourceGroupInner> clientResponse = getDelegate(response);
//                            return Observable.just(clientResponse);
//                        } catch (Throwable t) {
//                            return Observable.error(t);
//                        }
//                    }
//                });
    }

    public Mono<ResourceGroupInner> createOrUpdateAsync(String resourceGroupName, ResourceGroupInner parameters) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        // Validator.validate(parameters);
        Mono<Response<ResourceGroupInner>> observable = service.createOrUpdate(resourceGroupName, this.client.subscriptionId(), parameters, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        //  .flatMap(response -> Mono.just(response.getValue()));
        return client.getAzureClient().getPutOrPatchResultAsync(observable)
                .takeWhile(apr -> apr.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED)
                .next()
                .flatMap(val -> Mono.just(val.getValue().value()));
    }

    public Boolean checkExistence(String resourceGroupName) {
        return this.checkExistenceAsync(resourceGroupName).block();
    }

    public Mono<Boolean> checkExistenceAsync(String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.checkExistence(resourceGroupName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
                .flatMap(res -> Mono.just(res.getValue()));
//                .flatMap(new Func1<Response<Void>, Observable<ServiceResponse<Boolean>>>() {
//                    @Override
//                    public Observable<ServiceResponse<Boolean>> call(Response<Void> response) {
//                        try {
//                            ServiceResponse<Boolean> clientResponse = checkExistenceByIdDelegate(response);
//                            return Observable.just(clientResponse);
//                        } catch (Throwable t) {
//                            return Observable.error(t);
//                        }
//                    }
//                });
    }

    public PagedFlux<ResourceGroupInner> listAsync(String filter, Integer top) {
        return new PagedFlux<>(
                () -> listResourceGroupsFirstPage(filter, top),
                continuationToken -> listResourceGroupsNextPage(continuationToken));
    }

    public PagedList<ResourceGroupInner> list(String filter, Integer top) {
        PagedResponse<ResourceGroupInner> response = listResourceGroupsFirstPage(filter, top).block();
        return new PagedList<ResourceGroupInner>(response) {
            @Override
            public Page<ResourceGroupInner> nextPage(String nextPageLink) {
                return listResourceGroupsNextPage(nextPageLink).block();
            }
        };
    }

    public PagedFlux<ResourceGroupInner> listAsync() {
        return new PagedFlux<>(
                () -> listResourceGroupsFirstPage(null, null),
                continuationToken -> listResourceGroupsNextPage(continuationToken));
    }

    public PagedList<ResourceGroupInner> list() {
        PagedResponse<ResourceGroupInner> response = listResourceGroupsFirstPage(null, null).block();
        return new PagedList<ResourceGroupInner>(response) {
            @Override
            public Page<ResourceGroupInner> nextPage(String nextPageLink) {
                return listResourceGroupsNextPage(nextPageLink).block();
            }
        };
    }

    /*
     * Calls the service and retrieve first page result. It makes one call and retrieve {@code
     * DEFAULT_MAX_PAGE_RESULTS} values.
     */
    private Mono<PagedResponse<ResourceGroupInner>> listResourceGroupsFirstPage(String filter, Integer top) {
        try {
            return service.list(this.client.subscriptionId(), filter, top, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
                    .doOnRequest(ignored -> logger.info("Listing deployments"))
                    .doOnSuccess(response -> logger.info("Listed deployments"))
                    .doOnError(error -> logger.warning("Failed to list deployments", error));
        } catch (RuntimeException ex) {
            return Mono.error(logger.logExceptionAsError(Exceptions.propagate(ex)));
        }
    }


    /*
     * Gets attributes of all the secrets given by the {@code nextPageLink} that was retrieved from a call to
     * {@link SecretAsyncClient#listSecrets()}.
     *
     * @param continuationToken The {@link PagedResponse#nextLink()} from a previous, successful call to one of the
     * list operations.
     * @return A {@link Mono} of {@link PagedResponse<SecretProperties>} from the next page of results.
     */
    private Mono<PagedResponse<ResourceGroupInner>> listResourceGroupsNextPage(String continuationToken) {
        try {
            return service.listNext(continuationToken, this.client.acceptLanguage(), this.client.userAgent())
                    .doOnRequest(ignoredValue -> logger.info("Retrieving the next secrets page - Page {}", continuationToken))
                    .doOnSuccess(response -> logger.info("Retrieved the next secrets page - Page {}", continuationToken))
                    .doOnError(error -> logger.warning("Failed to retrieve the next secrets page - Page {}",
                            continuationToken, error));
        } catch (RuntimeException ex) {
            return Mono.error(logger.logExceptionAsError(Exceptions.propagate(ex)));
        }
    }

    public Mono<Void> deleteAsync(String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Mono<Response<Void>> observable = service.delete(resourceGroupName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());

        return client.getAzureClient().getPostOrDeleteResultAsync(observable)
                .takeWhile(apr -> apr.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED)
                .next()
                .flatMap(val -> Mono.just(val.getValue().value()));
    }


    public Mono<Void> beginDeleteAsync(String resourceGroupName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException("Parameter resourceGroupName is required and cannot be null.");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException("Parameter this.client.subscriptionId() is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.beginDelete(resourceGroupName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
                .flatMap(res -> Mono.just(res.getValue()));
//                .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
//                    @Override
//                    public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
//                        try {
//                            ServiceResponse<Void> clientResponse = beginDeleteDelegate(response);
//                            return Observable.just(clientResponse);
//                        } catch (Throwable t) {
//                            return Observable.error(t);
//                        }
//                    }
//                });
    }


    /**
     * The interface defining all the services for ResourceGroups to be
     * used by Retrofit to perform actually REST calls.
     */
    /**
     * The interface defining all the services for ResourceGroups to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ResourceGroupsService {
        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resources.ResourceGroups checkExistence"})
        @Head("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}")
        Mono<Response<Boolean>> checkExistence(@PathParam("resourceGroupName") String resourceGroupName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion, @HeaderParam("accept-language") String acceptLanguage, @HeaderParam("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resources.ResourceGroups createOrUpdate"})
        @Put("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}")
        Mono<Response<ResourceGroupInner>> createOrUpdate(@PathParam("resourceGroupName") String resourceGroupName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("body") ResourceGroupInner parameters, @QueryParam("api-version") String apiVersion, @HeaderParam("accept-language") String acceptLanguage, @HeaderParam("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resources.ResourceGroups delete"})
        @Delete("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}")
        Mono<Response<Void>> delete(@PathParam("resourceGroupName") String resourceGroupName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion, @HeaderParam("accept-language") String acceptLanguage, @HeaderParam("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resources.ResourceGroups beginDelete"})
        @Delete("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}")
        Mono<Response<Void>> beginDelete(@PathParam("resourceGroupName") String resourceGroupName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion, @HeaderParam("accept-language") String acceptLanguage, @HeaderParam("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resources.ResourceGroups get"})
        @Get("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}")
        Mono<Response<ResourceGroupInner>> get(@PathParam("resourceGroupName") String resourceGroupName, @PathParam("subscriptionId") String subscriptionId, @QueryParam("api-version") String apiVersion, @HeaderParam("accept-language") String acceptLanguage, @HeaderParam("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resources.ResourceGroups update"})
        @Patch("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}")
        Mono<Response<ResourceGroupInner>> update(@PathParam("resourceGroupName") String resourceGroupName, @PathParam("subscriptionId") String subscriptionId, @BodyParam("body") ResourceGroupPatchable parameters, @QueryParam("api-version") String apiVersion, @HeaderParam("accept-language") String acceptLanguage, @HeaderParam("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resources.ResourceGroups exportTemplate"})
        @Post("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/exportTemplate")
        Mono<Response<ResourceGroupExportResultInner>> exportTemplate(@PathParam("subscriptionId") String subscriptionId, @PathParam("resourceGroupName") String resourceGroupName, @QueryParam("api-version") String apiVersion, @BodyParam("body") ExportTemplateRequest parameters, @HeaderParam("accept-language") String acceptLanguage, @HeaderParam("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resources.ResourceGroups beginExportTemplate"})
        @Post("subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/exportTemplate")
        Mono<Response<ResourceGroupExportResultInner>> beginExportTemplate(@PathParam("subscriptionId") String subscriptionId, @PathParam("resourceGroupName") String resourceGroupName, @QueryParam("api-version") String apiVersion, @BodyParam("body") ExportTemplateRequest parameters, @HeaderParam("accept-language") String acceptLanguage, @HeaderParam("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resources.ResourceGroups list"})
        @Get("subscriptions/{subscriptionId}/resourcegroups")
        Mono<PagedResponse<ResourceGroupInner>> list(@PathParam("subscriptionId") String subscriptionId, @QueryParam("$filter") String filter, @QueryParam("$top") Integer top, @QueryParam("api-version") String apiVersion, @HeaderParam("accept-language") String acceptLanguage, @HeaderParam("User-Agent") String userAgent);

        @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.resources.ResourceGroups listNext"})
        @Get("{nextUrl}")
        Mono<PagedResponse<ResourceGroupInner>> listNext(@PathParam("nextUrl") String nextUrl, @HeaderParam("accept-language") String acceptLanguage, @HeaderParam("User-Agent") String userAgent);

    }
}
